{"ast":null,"code":"var stream = require('readable-stream');\nvar eos = require('end-of-stream');\nvar inherits = require('inherits');\nvar shift = require('stream-shift');\nvar SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);\nvar onuncork = function onuncork(self, fn) {\n  if (self._corked) self.once('uncork', fn);else fn();\n};\nvar autoDestroy = function autoDestroy(self, err) {\n  if (self._autoDestroy) self.destroy(err);\n};\nvar destroyer = function destroyer(self, end) {\n  return function (err) {\n    if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else if (end && !self._ended) self.end();\n  };\n};\nvar end = function end(ws, fn) {\n  if (!ws) return fn();\n  if (ws._writableState && ws._writableState.finished) return fn();\n  if (ws._writableState) return ws.end(fn);\n  ws.end();\n  fn();\n};\nvar toStreams2 = function toStreams2(rs) {\n  return new stream.Readable({\n    objectMode: true,\n    highWaterMark: 16\n  }).wrap(rs);\n};\nvar Duplexify = function Duplexify(writable, readable, opts) {\n  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);\n  stream.Duplex.call(this, opts);\n  this._writable = null;\n  this._readable = null;\n  this._readable2 = null;\n  this._autoDestroy = !opts || opts.autoDestroy !== false;\n  this._forwardDestroy = !opts || opts.destroy !== false;\n  this._forwardEnd = !opts || opts.end !== false;\n  this._corked = 1; // start corked\n  this._ondrain = null;\n  this._drained = false;\n  this._forwarding = false;\n  this._unwrite = null;\n  this._unread = null;\n  this._ended = false;\n  this.destroyed = false;\n  if (writable) this.setWritable(writable);\n  if (readable) this.setReadable(readable);\n};\ninherits(Duplexify, stream.Duplex);\nDuplexify.obj = function (writable, readable, opts) {\n  if (!opts) opts = {};\n  opts.objectMode = true;\n  opts.highWaterMark = 16;\n  return new Duplexify(writable, readable, opts);\n};\nDuplexify.prototype.cork = function () {\n  if (++this._corked === 1) this.emit('cork');\n};\nDuplexify.prototype.uncork = function () {\n  if (this._corked && --this._corked === 0) this.emit('uncork');\n};\nDuplexify.prototype.setWritable = function (writable) {\n  if (this._unwrite) this._unwrite();\n  if (this.destroyed) {\n    if (writable && writable.destroy) writable.destroy();\n    return;\n  }\n  if (writable === null || writable === false) {\n    this.end();\n    return;\n  }\n  var self = this;\n  var unend = eos(writable, {\n    writable: true,\n    readable: false\n  }, destroyer(this, this._forwardEnd));\n  var ondrain = function ondrain() {\n    var ondrain = self._ondrain;\n    self._ondrain = null;\n    if (ondrain) ondrain();\n  };\n  var clear = function clear() {\n    self._writable.removeListener('drain', ondrain);\n    unend();\n  };\n  if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks\n\n  this._writable = writable;\n  this._writable.on('drain', ondrain);\n  this._unwrite = clear;\n  this.uncork(); // always uncork setWritable\n};\n\nDuplexify.prototype.setReadable = function (readable) {\n  if (this._unread) this._unread();\n  if (this.destroyed) {\n    if (readable && readable.destroy) readable.destroy();\n    return;\n  }\n  if (readable === null || readable === false) {\n    this.push(null);\n    this.resume();\n    return;\n  }\n  var self = this;\n  var unend = eos(readable, {\n    writable: false,\n    readable: true\n  }, destroyer(this));\n  var onreadable = function onreadable() {\n    self._forward();\n  };\n  var onend = function onend() {\n    self.push(null);\n  };\n  var clear = function clear() {\n    self._readable2.removeListener('readable', onreadable);\n    self._readable2.removeListener('end', onend);\n    unend();\n  };\n  this._drained = true;\n  this._readable = readable;\n  this._readable2 = readable._readableState ? readable : toStreams2(readable);\n  this._readable2.on('readable', onreadable);\n  this._readable2.on('end', onend);\n  this._unread = clear;\n  this._forward();\n};\nDuplexify.prototype._read = function () {\n  this._drained = true;\n  this._forward();\n};\nDuplexify.prototype._forward = function () {\n  if (this._forwarding || !this._readable2 || !this._drained) return;\n  this._forwarding = true;\n  var data;\n  while (this._drained && (data = shift(this._readable2)) !== null) {\n    if (this.destroyed) continue;\n    this._drained = this.push(data);\n  }\n  this._forwarding = false;\n};\nDuplexify.prototype.destroy = function (err) {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  var self = this;\n  process.nextTick(function () {\n    self._destroy(err);\n  });\n};\nDuplexify.prototype._destroy = function (err) {\n  if (err) {\n    var ondrain = this._ondrain;\n    this._ondrain = null;\n    if (ondrain) ondrain(err);else this.emit('error', err);\n  }\n  if (this._forwardDestroy) {\n    if (this._readable && this._readable.destroy) this._readable.destroy();\n    if (this._writable && this._writable.destroy) this._writable.destroy();\n  }\n  this.emit('close');\n};\nDuplexify.prototype._write = function (data, enc, cb) {\n  if (this.destroyed) return cb();\n  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));\n  if (data === SIGNAL_FLUSH) return this._finish(cb);\n  if (!this._writable) return cb();\n  if (this._writable.write(data) === false) this._ondrain = cb;else cb();\n};\nDuplexify.prototype._finish = function (cb) {\n  var self = this;\n  this.emit('preend');\n  onuncork(this, function () {\n    end(self._forwardEnd && self._writable, function () {\n      // haxx to not emit prefinish twice\n      if (self._writableState.prefinished === false) self._writableState.prefinished = true;\n      self.emit('prefinish');\n      onuncork(self, cb);\n    });\n  });\n};\nDuplexify.prototype.end = function (data, enc, cb) {\n  if (typeof data === 'function') return this.end(null, null, data);\n  if (typeof enc === 'function') return this.end(data, null, enc);\n  this._ended = true;\n  if (data) this.write(data);\n  if (!this._writableState.ending) this.write(SIGNAL_FLUSH);\n  return stream.Writable.prototype.end.call(this, cb);\n};\nmodule.exports = Duplexify;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
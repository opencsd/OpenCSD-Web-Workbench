{"ast":null,"code":"exports.setopts = setopts;\nexports.ownProp = ownProp;\nexports.makeAbs = makeAbs;\nexports.finish = finish;\nexports.mark = mark;\nexports.isIgnored = isIgnored;\nexports.childrenIgnored = childrenIgnored;\nfunction ownProp(obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field);\n}\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar minimatch = require(\"minimatch\");\nvar isAbsolute = require(\"path-is-absolute\");\nvar Minimatch = minimatch.Minimatch;\nfunction alphasort(a, b) {\n  return a.localeCompare(b, 'en');\n}\nfunction setupIgnores(self, options) {\n  self.ignore = options.ignore || [];\n  if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap);\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap(pattern) {\n  var gmatcher = null;\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '');\n    gmatcher = new Minimatch(gpattern, {\n      dot: true\n    });\n  }\n  return {\n    matcher: new Minimatch(pattern, {\n      dot: true\n    }),\n    gmatcher: gmatcher\n  };\n}\nfunction setopts(self, pattern, options) {\n  if (!options) options = {};\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\");\n    }\n    pattern = \"**/\" + pattern;\n  }\n  self.silent = !!options.silent;\n  self.pattern = pattern;\n  self.strict = options.strict !== false;\n  self.realpath = !!options.realpath;\n  self.realpathCache = options.realpathCache || Object.create(null);\n  self.follow = !!options.follow;\n  self.dot = !!options.dot;\n  self.mark = !!options.mark;\n  self.nodir = !!options.nodir;\n  if (self.nodir) self.mark = true;\n  self.sync = !!options.sync;\n  self.nounique = !!options.nounique;\n  self.nonull = !!options.nonull;\n  self.nosort = !!options.nosort;\n  self.nocase = !!options.nocase;\n  self.stat = !!options.stat;\n  self.noprocess = !!options.noprocess;\n  self.absolute = !!options.absolute;\n  self.fs = options.fs || fs;\n  self.maxLength = options.maxLength || Infinity;\n  self.cache = options.cache || Object.create(null);\n  self.statCache = options.statCache || Object.create(null);\n  self.symlinks = options.symlinks || Object.create(null);\n  setupIgnores(self, options);\n  self.changedCwd = false;\n  var cwd = process.cwd();\n  if (!ownProp(options, \"cwd\")) self.cwd = cwd;else {\n    self.cwd = path.resolve(options.cwd);\n    self.changedCwd = self.cwd !== cwd;\n  }\n  self.root = options.root || path.resolve(self.cwd, \"/\");\n  self.root = path.resolve(self.root);\n  if (process.platform === \"win32\") self.root = self.root.replace(/\\\\/g, \"/\");\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);\n  if (process.platform === \"win32\") self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");\n  self.nomount = !!options.nomount;\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true;\n  options.nocomment = true;\n  // always treat \\ in patterns as escapes, not path separators\n  options.allowWindowsEscape = false;\n  self.minimatch = new Minimatch(pattern, options);\n  self.options = self.minimatch.options;\n}\nfunction finish(self) {\n  var nou = self.nounique;\n  var all = nou ? [] : Object.create(null);\n  for (var i = 0, l = self.matches.length; i < l; i++) {\n    var matches = self.matches[i];\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i];\n        if (nou) all.push(literal);else all[literal] = true;\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches);\n      if (nou) all.push.apply(all, m);else m.forEach(function (m) {\n        all[m] = true;\n      });\n    }\n  }\n  if (!nou) all = Object.keys(all);\n  if (!self.nosort) all = all.sort(alphasort);\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i]);\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !/\\/$/.test(e);\n        var c = self.cache[e] || self.cache[makeAbs(self, e)];\n        if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);\n        return notDir;\n      });\n    }\n  }\n  if (self.ignore.length) all = all.filter(function (m) {\n    return !isIgnored(self, m);\n  });\n  self.found = all;\n}\nfunction mark(self, p) {\n  var abs = makeAbs(self, p);\n  var c = self.cache[abs];\n  var m = p;\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c);\n    var slash = p.slice(-1) === '/';\n    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);\n    if (m !== p) {\n      var mabs = makeAbs(self, m);\n      self.statCache[mabs] = self.statCache[abs];\n      self.cache[mabs] = self.cache[abs];\n    }\n  }\n  return m;\n}\n\n// lotta situps...\nfunction makeAbs(self, f) {\n  var abs = f;\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f);\n  } else if (isAbsolute(f) || f === '') {\n    abs = f;\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f);\n  } else {\n    abs = path.resolve(f);\n  }\n  if (process.platform === 'win32') abs = abs.replace(/\\\\/g, '/');\n  return abs;\n}\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored(self, path) {\n  if (!self.ignore.length) return false;\n  return self.ignore.some(function (item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));\n  });\n}\nfunction childrenIgnored(self, path) {\n  if (!self.ignore.length) return false;\n  return self.ignore.some(function (item) {\n    return !!(item.gmatcher && item.gmatcher.match(path));\n  });\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}